using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows;

namespace Pharos.POS.Retailing.Models.Scanner
{
    public delegate void BardCodeDeletegate(BarCodes barCode);
    /// <summary>
    /// 虚拟键盘输入型扫码枪
    /// </summary>
    public class KeyboardScanner : IScanner
    {
        BardCodeHooK BarCode = new BardCodeHooK();
        public KeyboardScanner()
        {
            Type = ScannerType.Keyboard;
        }

        public void SetScanner(Window win, Action<string, ScannerType> SetValue)
        {
            BarCode.BarCodeEvent += new BardCodeDeletegate((o) =>
            {
                SetValue(o.BarCode, Type);
            });
            BarCode.Start();
            win.Closed += win_Closed;
        }

        void win_Closed(object sender, EventArgs e)
        {
            BarCode.Stop();
        }
        public ScannerType Type { get; private set; }

        public static bool CurrentEnter { get; set; }
     }


    /// <summary>
    /// 获取键盘输入或者USB扫描枪数据 可以是没有焦点 使用的是全局钩子
    /// USB扫描枪 是模拟键盘按下
    /// 这里主要处理扫描枪的值，手动输入的值不太好处理
    /// </summary>
    public class BardCodeHooK
    {

        public event BardCodeDeletegate BarCodeEvent;
        //定义成静态，这样不会抛出回收异常
        private static HookProc hookproc;
        BarCodes barCode = new BarCodes();
        int hKeyboardHook = 0;
        StringBuilder sbBarCode = new StringBuilder();

        [DllImport("user32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        private static extern int SetWindowsHookEx(int idHook, HookProc lpfn, IntPtr hInstance, int threadId);

        [DllImport("user32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        private static extern bool UnhookWindowsHookEx(int idHook);

        [DllImport("user32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
        private static extern int CallNextHookEx(int idHook, int nCode, Int32 wParam, IntPtr lParam);

        [DllImport("user32", EntryPoint = "GetKeyNameText")]
        private static extern int GetKeyNameText(int IParam, StringBuilder lpBuffer, int nSize);

        [DllImport("user32", EntryPoint = "GetKeyboardState")]
        private static extern int GetKeyboardState(byte[] pbKeyState);

        [DllImport("user32", EntryPoint = "ToAscii")]
        private static extern bool ToAscii(int VirtualKey, int ScanCode, byte[] lpKeySate, ref uint lpChar, int uFlags);

        [DllImport("kernel32.dll")]
        public static extern IntPtr GetModuleHandle(string name);

        delegate int HookProc(int nCode, Int32 wParam, IntPtr lParam);

        private int KeyboardHookProc(int nCode, Int32 wParam, IntPtr lParam)
        {
            int i_calledNext = -10;
            if (nCode == 0)
            {
                EventMsg msg = (EventMsg)Marshal.PtrToStructure(lParam, typeof(EventMsg));
                if (wParam == 0x100)//WM_KEYDOWN=0x100
                {
                    barCode.VirtKey = msg.message & 0xff;//虚拟吗
                    barCode.ScanCode = msg.paramL & 0xff;//扫描码
                    StringBuilder strKeyName = new StringBuilder(225);
                    if (GetKeyNameText(barCode.ScanCode * 65536, strKeyName, 255) > 0)
                    {
                        barCode.KeyName = strKeyName.ToString().Trim(new char[] { ' ', '\0' });
                    }
                    else
                    {
                        barCode.KeyName = "";
                    }
                    byte[] kbArray = new byte[256];
                    uint uKey = 0;
                    GetKeyboardState(kbArray);

                    if (ToAscii(barCode.VirtKey, barCode.ScanCode, kbArray, ref uKey, 0))
                    {
                        barCode.Ascll = uKey;
                        barCode.Chr = Convert.ToChar(uKey);

                        barCode.OriginalChrs += " " + Convert.ToString(barCode.Chr);
                        barCode.OriginalAsciis += " " + Convert.ToString(barCode.Ascll);
                        if (barCode.Chr != 13)
                            barCode.OriginalBarCode += Convert.ToString(barCode.Chr);
                    }
                    TimeSpan ts = DateTime.Now.Subtract(barCode.Time);
                    if (ts.TotalMilliseconds > 30)
                    {//时间戳，大于50 毫秒表示手动输入
                        sbBarCode.Remove(0, sbBarCode.Length);
                        sbBarCode.Append(barCode.Chr.ToString());
                        barCode.OriginalChrs = " " + Convert.ToString(barCode.Chr);
                        barCode.OriginalAsciis = " " + Convert.ToString(barCode.Ascll);
                        barCode.OriginalBarCode = Convert.ToString(barCode.Chr);
                    }
                    else
                    {
                        if ((msg.message & 0xff) == 13 && sbBarCode.Length > 3)
                        {//回车
                            barCode.BarCode = barCode.OriginalBarCode;
                            KeyboardScanner.CurrentEnter = true;
                            barCode.IsValid = true;
                            sbBarCode.Remove(0, sbBarCode.Length);
                        }

                        sbBarCode.Append(barCode.Chr.ToString());
                    }
                    try
                    {
                        if (BarCodeEvent != null && barCode.IsValid)
                        {
                            //先进行 WINDOWS事件往下传
                            i_calledNext = CallNextHookEx(hKeyboardHook, nCode, wParam, lParam);
                            BarCodeEvent(barCode);//触发事件
                            barCode.BarCode = "";
                            barCode.OriginalChrs = "";
                            barCode.OriginalAsciis = "";
                            barCode.OriginalBarCode = "";
                        }

                    }
                    catch { }
                    finally
                    {
                        barCode.IsValid = false; //最后一定要 设置barCode无效
                        barCode.Time = DateTime.Now;
                    }
                }
            }
            if (i_calledNext == -10)
            {
                i_calledNext = CallNextHookEx(hKeyboardHook, nCode, wParam, lParam);
            }
            return i_calledNext;
        }

        //安装钩子
        public bool Start()
        {
            if (hKeyboardHook == 0)
            {
                hookproc = new HookProc(KeyboardHookProc);
                //防止在 framework4.0中 注册钩子不成功
                IntPtr modulePtr = GetModuleHandle(Process.GetCurrentProcess().MainModule.ModuleName);
                hKeyboardHook = SetWindowsHookEx(13, hookproc, modulePtr, 0);
            }
            return (hKeyboardHook != 0);
        }

        //卸载钩子
        public bool Stop()
        {
            if (hKeyboardHook != 0)
            {
                return UnhookWindowsHookEx(hKeyboardHook);
            }
            return true;
        }

    }

    /// <summary>
    /// 钩子消息
    /// </summary>
    public struct EventMsg
    {
        public int message;
        public int paramL;
        public int paramH;
        public int Time;
        public int hwnd;
    }
    /// <summary>
    /// 扫码信息
    /// </summary>
    public struct BarCodes
    {
        public int VirtKey { get; set; }//虚拟吗
        public int ScanCode { get; set; }//扫描码
        public string KeyName { get; set; }//键名
        public uint Ascll { get; set; }//Ascll
        public char Chr { get; set; }//字符
        public string OriginalChrs { get; set; } //原始 字符
        public string OriginalAsciis { get; set; }//原始 ASCII
        public string OriginalBarCode { get; set; }  //原始数据条码
        public bool IsValid { get; set; }//条码是否有效
        public DateTime Time { get; set; }//扫描时间,
        public string BarCode { get; set; }//条码信息   保存最终的条码
    }


}
