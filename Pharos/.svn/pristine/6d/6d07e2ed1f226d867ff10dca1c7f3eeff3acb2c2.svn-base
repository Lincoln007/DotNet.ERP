using Microsoft.Synchronization;
using Microsoft.Synchronization.MetadataStorage;
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;

namespace Pharos.SyncService
{
    public class PosDbSyncProvider : KnowledgeSyncProvider, IChangeDataRetriever, INotifyingChangeApplierTarget
    {
        private string _replicaMetadataFile;
        private string _replicaIdFile;
        private SyncIdFormatGroup _idFormats;
        private SyncId _replicaId;
        ReplicaMetadata _metadata = null;
        SqlMetadataStore _metadataStore = null;
        const string TIMESTAMP_COLUMNNAME = "timestamp";
        const string ENTITY_COLUMNNAME = "entity";

        //  IPosServerDbStore _store;
        private SyncSessionContext _currentSessionContext;
        private ISyncContext _syncContext;
        public string StoreId { get; set; }
        public int CompanyId { get; set; }
        public SyncId ReplicaId
        {
            get
            {
                if (_replicaId == null)
                {
                    _replicaId = GetReplicaIdFromFile(_replicaIdFile);
                }

                return _replicaId;
            }
        }


        public PosDbSyncProvider(int companyId, string storeId, ISyncContext syncContext)
        {
            CompanyId = companyId;
            StoreId = storeId;
            _syncContext = syncContext;
            // _store = store;
            var syncTempDirectory = "SyncTemp";
            var syncDirectory = string.Format(@"{0}{1}\", AppDomain.CurrentDomain.BaseDirectory, syncTempDirectory);
            if (!Directory.Exists(syncDirectory))
            {
                Directory.CreateDirectory(syncDirectory);
            }
            _replicaMetadataFile = string.Format(@"{0}{3}\{1}_{2}.Metadata", AppDomain.CurrentDomain.BaseDirectory, companyId, storeId, syncTempDirectory);
            _replicaIdFile = string.Format(@"{0}{3}\{1}_{2}.Replicaid", AppDomain.CurrentDomain.BaseDirectory, companyId, storeId, syncTempDirectory);

            _idFormats = new SyncIdFormatGroup();
            _idFormats.ItemIdFormat.IsVariableLength = false;
            _idFormats.ItemIdFormat.Length = 16;
            _idFormats.ReplicaIdFormat.IsVariableLength = false;
            _idFormats.ReplicaIdFormat.Length = 16;
        }

        #region Methods necessary for Remote Change Application
        public void BeginSession()
        {
            InitializeMetadataStore();
            //   _store = MySimpleDataStore.ReadStoreFromFile(_folderPath, _name);

            //Make sure the metadata store is updated to reflect the state of the data before each sync operation.
            _metadataStore.BeginTransaction();
            UpdateMetadataStoreWithLocalChanges();
            _metadataStore.CommitTransaction();
        }

        public void EndSession()
        {
            // _store.WriteStoreToFile(_folderPath, _name);
            CloseMetadataStore();
        }

        //Change application!
        public byte[] ProcessRemoteChangeBatch(ConflictResolutionPolicy resolutionPolicy, ChangeBatch sourceChanges, CachedChangeDataRetriever changeDataRetriever, byte[] changeApplierInfo)
        {
            _metadataStore.BeginTransaction();

            //Get all my local change versions from the metadata store
            IEnumerable<ItemChange> localChanges = _metadata.GetLocalVersions(sourceChanges);

            NotifyingChangeApplier changeApplier = new NotifyingChangeApplier(_idFormats);

            // The following step is required because we are remote change application
            changeApplier.LoadChangeApplierInfo(changeApplierInfo);

            changeApplier.ApplyChanges(
                resolutionPolicy,
                sourceChanges,
                changeDataRetriever,
                localChanges,
                _metadata.GetKnowledge(),
                _metadata.GetForgottenKnowledge(),
                this,
                null,                     // Note that we do not pass a sync session context
                new SyncCallbacks());

            _metadataStore.CommitTransaction();

            // Return the ChangeApplierInfo
            return changeApplier.GetChangeApplierInfo();
        }

        //If full enumeration is needed because  this provider is out of date due to tombstone cleanup, then this method will be called by the engine.
        public byte[] ProcessRemoteFullEnumerationChangeBatch(ConflictResolutionPolicy resolutionPolicy, FullEnumerationChangeBatch sourceChanges, CachedChangeDataRetriever changeDataRetriever, byte[] changeApplierInfo)
        {
            _metadataStore.BeginTransaction();

            //Get all my local change versions from the metadata store
            IEnumerable<ItemChange> localChanges = _metadata.GetFullEnumerationLocalVersions(sourceChanges);

            NotifyingChangeApplier changeApplier = new NotifyingChangeApplier(_idFormats);

            // The following step is required because we are remote change application
            changeApplier.LoadChangeApplierInfo(changeApplierInfo);

            changeApplier.ApplyFullEnumerationChanges(
                resolutionPolicy,
                sourceChanges,
                changeDataRetriever as IChangeDataRetriever,
                localChanges,
                _metadata.GetKnowledge(),
                _metadata.GetForgottenKnowledge(),
                this,
                null,                   // Note that we do not pass a sync session context
                new SyncCallbacks());

            _metadataStore.CommitTransaction();

            // Return the ChangeApplierInfo
            return changeApplier.GetChangeApplierInfo();
        }
        #endregion

        #region Metadata Store Related Methods
        private void InitializeMetadataStore()
        {
            // Values for adding a custom field to the metadata store
            List<FieldSchema> fields = new List<FieldSchema>();
            SyncId id = ReplicaId;

            // Create or open the metadata store, initializing it with the id formats we'll use to reference our items and endpoints
            if (!File.Exists(_replicaMetadataFile))
            {
                fields.Add(new FieldSchema(TIMESTAMP_COLUMNNAME, typeof(UInt64)));
                fields.Add(new FieldSchema(ENTITY_COLUMNNAME, typeof(string), 400));
                _metadataStore = SqlMetadataStore.CreateStore(_replicaMetadataFile);
                _metadata = _metadataStore.InitializeReplicaMetadata(_idFormats, _replicaId, fields, null/*No indexes to create*/);
            }
            else
            {
                _metadataStore = SqlMetadataStore.OpenStore(_replicaMetadataFile);
                _metadata = _metadataStore.GetReplicaMetadata(_idFormats, _replicaId);
            }
        }

        private void CloseMetadataStore()
        {
            _metadataStore.Dispose();
            _metadataStore = null;
        }

        //Update the metadata store with changes that have occured on the data store since the last time it was updated.
        public void UpdateMetadataStoreWithLocalChanges()
        {
            SyncVersion newVersion = new SyncVersion(0, _metadata.GetNextTickCount());

            _metadata.DeleteDetector.MarkAllItemsUnreported();
            foreach (var map in _syncContext.ServiceMappings)
            {
                var entities = map.Value.GetSyncObjects();
                foreach (ISyncDataObject entity in entities)
                {
                    ISyncDataObject data = entity;
                    ItemMetadata item = null;

                    //Look up an item's metadata by its ID... 
                    item = _metadata.FindItemMetadataById(new SyncId(entity.SyncItemId));
                    if (null == item)
                    {
                        //New item, must have been created since that last time the metadata was updated.
                        //Create the item metadata required for sync (giving it a SyncID and a version, defined to be a DWORD and a ULONGLONG
                        //For creates, simply provide the relative replica ID (0) and the tick count for the provider (ever increasing)
                        item = _metadata.CreateItemMetadata(new SyncId(entity.SyncItemId), newVersion);
                        item.ChangeVersion = newVersion;
                        SaveItemMetadata(item, BitConverter.ToUInt64(data.SyncItemVersion, 0), map.Key);
                    }
                    else
                    {
                        if (BitConverter.ToUInt64(data.SyncItemVersion, 0) != item.GetUInt64Field(TIMESTAMP_COLUMNNAME)) // the item has changed since the last sync operation.
                        {
                            //Changed Item, this item has changed since the last time the metadata was updated.
                            //Assign a new version by simply stating "who" modified this item (0 = local/me) and "when" (tick count for the store)
                            item.ChangeVersion = newVersion;
                            SaveItemMetadata(item, BitConverter.ToUInt64(data.SyncItemVersion, 0), map.Key);
                        }
                        else
                        {
                            //Unchanged item, nothing has changes so just mark it as live so that the metadata knows it has not been deleted.
                            _metadata.DeleteDetector.ReportLiveItemById(new SyncId(entity.SyncItemId));
                        }
                    }
                }
            }

            //Now go back through the items that are no longer in the store and mark them as deleted in the metadata.  
            //This sets the item as a tombstone.
            foreach (ItemMetadata item in _metadata.DeleteDetector.FindUnreportedItems())
            {
                item.MarkAsDeleted(newVersion);
                SaveItemMetadata(item, 0, item.GetStringField(ENTITY_COLUMNNAME)); // set timestamp to null for tombstones
            }

        }

        private void SaveItemMetadata(ItemMetadata item, UInt64 timeStamp, string entityType)
        {
            item.SetCustomField(TIMESTAMP_COLUMNNAME, timeStamp);
            item.SetCustomField(ENTITY_COLUMNNAME, entityType);
            SaveItemMetadata(item);
        }

        private void SaveItemMetadata(ItemMetadata item)
        {
            _metadata.SaveItemMetadata(item);
        }

        // Method for cleaning up tombstones older than a certain TimeSpan
        public void CleanupTombstones(TimeSpan timespan)
        {
            InitializeMetadataStore();
            _metadataStore.BeginTransaction();
            _metadata.CleanupDeletedItems(timespan);
            _metadataStore.CommitTransaction();
            CloseMetadataStore();
        }
        #endregion Metadata Store Related Methods

        #region ReplicaId Initialization Methods
        private static SyncId GetReplicaIdFromFile(string replicaIdFile)
        {
            SyncId replicaId;

            if (System.IO.File.Exists(replicaIdFile))
            {
                replicaId = ReadReplicaIdFromFile(replicaIdFile);
            }
            else
            {
                // Create the replica id and save it.
                replicaId = new SyncId(Guid.NewGuid());
                WriteReplicaIdToFile(replicaIdFile, replicaId);
            }

            return replicaId;
        }
        private static void WriteReplicaIdToFile(string file, SyncId replicaId)
        {
            FileStream fs = new FileStream(file, FileMode.Create);

            // Construct a BinaryFormatter and use it to serialize the data to the stream.
            BinaryFormatter formatter = new BinaryFormatter();
            try
            {
                formatter.Serialize(fs, replicaId);
            }
            catch (SerializationException e)
            {
                Console.WriteLine("Failed to serialize replica id to file. Reason: " + e.Message);
                throw;
            }
            finally
            {
                fs.Close();
            }
        }
        private static SyncId ReadReplicaIdFromFile(string file)
        {
            FileStream fs = new FileStream(file, FileMode.Open);
            SyncId replicaId;

            // Construct a BinaryFormatter and use it to serialize the data to the stream.
            BinaryFormatter formatter = new BinaryFormatter();
            try
            {
                replicaId = (SyncId)formatter.Deserialize(fs);
            }
            catch (SerializationException e)
            {
                Console.WriteLine("Failed to deserialize replica id from file. Reason: " + e.Message);
                throw;
            }
            finally
            {
                fs.Close();
            }

            return replicaId;
        }
        #endregion ReplicaId Initialization Methods

        #region KnowledgeSyncProvider
        public override void BeginSession(SyncProviderPosition position, SyncSessionContext syncSessionContext)
        {
            BeginSession();
            _currentSessionContext = syncSessionContext;
        }

        public override void EndSession(SyncSessionContext syncSessionContext)
        {
            EndSession();
        }

        public override ChangeBatch GetChangeBatch(uint batchSize, SyncKnowledge destinationKnowledge, out object changeDataRetriever)
        {
            ChangeBatch batch = _metadata.GetChangeBatch(batchSize, destinationKnowledge);
            changeDataRetriever = this; //this is where the transfer mechanism/protocol would go. For an in memory provider, this is sufficient
            return batch;
        }

        public override FullEnumerationChangeBatch GetFullEnumerationChangeBatch(uint batchSize, SyncId lowerEnumerationBound, SyncKnowledge knowledgeForDataRetrieval, out object changeDataRetriever)
        {
            FullEnumerationChangeBatch batch = _metadata.GetFullEnumerationChangeBatch(batchSize, lowerEnumerationBound, knowledgeForDataRetrieval);
            changeDataRetriever = this; //this is where the transfer mechanism/protocol would go. For an in memory provider, this is sufficient
            return batch;
        }

        public override void GetSyncBatchParameters(out uint batchSize, out SyncKnowledge knowledge)
        {
            batchSize = 10;
            knowledge = _metadata.GetKnowledge();
        }

        public override SyncIdFormatGroup IdFormats
        {
            get { return _idFormats; }
        }

        public override void ProcessChangeBatch(ConflictResolutionPolicy resolutionPolicy, ChangeBatch sourceChanges, object changeDataRetriever, SyncCallbacks syncCallbacks, SyncSessionStatistics sessionStatistics)
        {
            _metadataStore.BeginTransaction();

            //Get all my local change versions from the metadata store
            IEnumerable<ItemChange> localChanges = _metadata.GetLocalVersions(sourceChanges);

            //Create a changeapplier object to make change application easier (make the engine call me 
            //when it needs data and when I should save data)
            NotifyingChangeApplier changeApplier = new NotifyingChangeApplier(_idFormats);

            changeApplier.ApplyChanges(resolutionPolicy, sourceChanges, changeDataRetriever as IChangeDataRetriever, localChanges, _metadata.GetKnowledge(),
                _metadata.GetForgottenKnowledge(), this, _currentSessionContext, syncCallbacks);

            _metadataStore.CommitTransaction();
        }

        public override void ProcessFullEnumerationChangeBatch(ConflictResolutionPolicy resolutionPolicy, FullEnumerationChangeBatch sourceChanges, object changeDataRetriever, SyncCallbacks syncCallbacks, SyncSessionStatistics sessionStatistics)
        {
            _metadataStore.BeginTransaction();

            //Get all my local change versions from the metadata store
            IEnumerable<ItemChange> localChanges = _metadata.GetFullEnumerationLocalVersions(sourceChanges);

            //Create a changeapplier object to make change application easier (make the engine call me 
            //when it needs data and when I should save data)
            NotifyingChangeApplier changeApplier = new NotifyingChangeApplier(_idFormats);
            changeApplier.ApplyFullEnumerationChanges(resolutionPolicy, sourceChanges, changeDataRetriever as IChangeDataRetriever, localChanges, _metadata.GetKnowledge(),
                _metadata.GetForgottenKnowledge(), this, _currentSessionContext, syncCallbacks);

            _metadataStore.CommitTransaction();
        }
        #endregion KnowledgeSyncProvider

        #region IChangeDataRetriever

        public object LoadChangeData(LoadChangeContext loadChangeContext)
        {
            ItemMetadata item;

            // Retrieve metadata for the changed item

            item = _metadata.FindItemMetadataById(loadChangeContext.ItemChange.ItemId);
            var key = item.GetStringField(ENTITY_COLUMNNAME);
            var dataService = _syncContext.GetDataService(key);
            return dataService.GetItem(loadChangeContext.ItemChange.ItemId.GetGuidId());
        }
        #endregion IChangeDataRetriever

        #region INotifyingChangeApplierTarget
        public IChangeDataRetriever GetDataRetriever()
        {
            return this;
        }

        public ulong GetNextTickCount()
        {
            return _metadata.GetNextTickCount();
        }

        public void SaveChangeWithChangeUnits(ItemChange change, SaveChangeWithChangeUnitsContext context)
        {
            throw new NotImplementedException();
        }

        public void SaveConflict(ItemChange conflictingChange, object conflictingChangeData, SyncKnowledge conflictingChangeKnowledge)
        {
            throw new NotImplementedException();
        }

        public void SaveItemChange(SaveChangeAction saveChangeAction, ItemChange change, SaveChangeContext context)
        {
            UInt64 timeStamp = 0;
            ItemMetadata item = null;
            ISyncDataObject data = null;
            switch (saveChangeAction)
            {
                case SaveChangeAction.Create:
                    //Do duplicate detection here
                    item = _metadata.FindItemMetadataById(change.ItemId);
                    if (null != item)
                    {
                        throw new Exception("SaveItemChange must not have Create action for existing items.");
                    }
                    item = _metadata.CreateItemMetadata(change.ItemId, change.CreationVersion);
                    item.ChangeVersion = change.ChangeVersion;
                    data = (ISyncDataObject)context.ChangeData;
                    //We are using the same id for both the local and global item id.
                    var key = context.ChangeData.GetType().ToString();
                    if (_syncContext.Contains(key))
                    {
                        var dataService = _syncContext.GetDataService(key);
                        dataService.CreateItem(data, change.ItemId.GetGuidId());
                        SaveItemMetadata(item, BitConverter.ToUInt64(dataService.GetItem(change.ItemId.GetGuidId()).SyncItemVersion, 0), key);
                    }

                    break;

                case SaveChangeAction.UpdateVersionAndData:
                case SaveChangeAction.UpdateVersionOnly:
                    item = _metadata.FindItemMetadataById(change.ItemId);
                    if (null == item)
                    {
                        throw new Exception("Item Not Found in Store!?");
                    }

                    item.ChangeVersion = change.ChangeVersion;
                    if (saveChangeAction == SaveChangeAction.UpdateVersionOnly)
                    {
                        SaveItemMetadata(item);
                    }
                    else  //Also update the data and the timestamp.
                    {
                        data = (ISyncDataObject)context.ChangeData;
                        key = context.ChangeData.GetType().ToString();
                        if (_syncContext.Contains(key))
                        {
                            var dataService = _syncContext.GetDataService(key);
                            timeStamp = BitConverter.ToUInt64(dataService.UpdateItem(item.GlobalId.GetGuidId(), data), 0);
                            SaveItemMetadata(item, timeStamp, key);
                        }
                    }
                    break;

                case SaveChangeAction.DeleteAndStoreTombstone:
                    item = _metadata.FindItemMetadataById(change.ItemId);
                    if (null == item)
                    {
                        item = _metadata.CreateItemMetadata(change.ItemId, change.CreationVersion);
                    }

                    if (change.ChangeKind == ChangeKind.Deleted)
                    {
                        item.MarkAsDeleted(change.ChangeVersion);
                    }
                    else
                    {
                        // This should never happen in Sync Framework V1.0
                        throw new Exception("Invalid ChangeType");
                    }

                    item.ChangeVersion = change.ChangeVersion;
                    key = item.GetStringField(ENTITY_COLUMNNAME);
                    if (_syncContext.Contains(key))
                    {
                        var dataService = _syncContext.GetDataService(key);
                        SaveItemMetadata(item, timeStamp, key);  // set timestamp to 0 for tombstones
                        dataService.DeleteItem(item.GlobalId.GetGuidId());
                    }
                    break;

                //Merge the changes! (Take the data from the local item + the remote item),noting to update the tick count to propagate the resolution!
                case SaveChangeAction.UpdateVersionAndMergeData:
                    item = _metadata.FindItemMetadataById(change.ItemId);

                    if (null == item)
                    {
                        throw new Exception("Item Not Found in Store!?");
                    }
                    if (item.IsDeleted != true)
                    {
                        //Note - you must update the change version to propagate the resolution!
                        item.ChangeVersion = new SyncVersion(0, _metadata.GetNextTickCount());
                        key = context.ChangeData.GetType().ToString();
                        if (_syncContext.Contains(key))
                        {
                            var dataService = _syncContext.GetDataService(key);
                            //Combine the conflicting data...
                            ISyncDataObject mergedData = dataService.Merge(dataService.GetItem(item.GlobalId.GetGuidId()), (ISyncDataObject)context.ChangeData);
                            timeStamp = BitConverter.ToUInt64(dataService.UpdateItem(item.GlobalId.GetGuidId(), mergedData), 0);
                            SaveItemMetadata(item, timeStamp, key);
                        }
                    }
                    break;

                case SaveChangeAction.DeleteAndRemoveTombstone:
                    item = _metadata.FindItemMetadataById(change.ItemId);
                    if (item != null)
                    {
                        List<SyncId> ids = new List<SyncId>();
                        ids.Add(item.GlobalId);
                        _metadata.RemoveItemMetadata(ids);
                    }
                    key = context.ChangeData.GetType().ToString();
                    if (_syncContext.Contains(key))
                    {
                        var dataService = _syncContext.GetDataService(key);
                        dataService.DeleteItem(change.ItemId.GetGuidId());
                    }
                    break;
            }
        }

        public void StoreKnowledgeForScope(SyncKnowledge knowledge, ForgottenKnowledge forgottenKnowledge)
        {
            _metadata.SetKnowledge(knowledge);
            _metadata.SetForgottenKnowledge(forgottenKnowledge);

            _metadata.SaveReplicaMetadata();
        }

        public bool TryGetDestinationVersion(ItemChange sourceChange, out ItemChange destinationVersion)
        {
            ItemMetadata metadata = _metadata.FindItemMetadataById(sourceChange.ItemId);

            if (metadata == null)
            {
                destinationVersion = null;
                return false;
            }
            else
            {
                destinationVersion = new ItemChange(_idFormats, _replicaId, sourceChange.ItemId,
                        metadata.IsDeleted ? ChangeKind.Deleted : ChangeKind.Update,
                        metadata.CreationVersion, metadata.ChangeVersion);
                return true;
            }
        }
        #endregion INotifyingChangeApplierTarget

    }
}