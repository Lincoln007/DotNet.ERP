using SuperSocket.ProtoBase;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Pharos.Logic.ApiData.Pos.DataSynchronism.Extensions
{
    public static class BinaryExtensions
    {
        public static T[] CloneRange<T>(this IList<T> source, int offset, int length)
        {
            T[] localArray;
            T[] sourceArray = source as T[];
            if (sourceArray != null)
            {
                localArray = new T[length];
                Array.Copy(sourceArray, offset, localArray, 0, length);
                return localArray;
            }
            localArray = new T[length];
            for (int i = 0; i < length; i++)
            {
                localArray[i] = source[offset + i];
            }
            return localArray;
        }

        public static bool EndsWith<T>(this IList<T> source, T[] mark) where T : IEquatable<T>
        {
            return source.EndsWith<T>(0, source.Count, mark);
        }

        public static bool EndsWith<T>(this IList<T> source, int offset, int length, T[] mark) where T : IEquatable<T>
        {
            if (mark.Length > length)
            {
                return false;
            }
            for (int i = 0; i < Math.Min(length, mark.Length); i++)
            {
                if (!mark[i].Equals(source[((offset + length) - mark.Length) + i]))
                {
                    return false;
                }
            }
            return true;
        }

        public static int IndexOf<T>(this IList<T> source, T target, int pos, int length) where T : IEquatable<T>
        {
            for (int i = pos; i < (pos + length); i++)
            {
                T local = source[i];
                if (local.Equals(target))
                {
                    return i;
                }
            }
            return -1;
        }

        public static int? SearchMark<T>(this IList<T> source, T[] mark) where T : IEquatable<T>
        {
            int num;
            return source.SearchMark<T>(0, source.Count, mark, 0, out num);
        }

        public static int? SearchMark<T>(this IList<T> source, T[] mark, out int parsedLength) where T : IEquatable<T>
        {
            return source.SearchMark<T>(0, source.Count, mark, 0, out parsedLength);
        }

        public static int SearchMark<T>(this IList<T> source, int offset, int length, SearchMarkState<T> searchState) where T : IEquatable<T>
        {
            int parsedLength = 0;
            return source.SearchMark<T>(offset, length, searchState, out parsedLength);
        }

        public static int? SearchMark<T>(this IList<T> source, int offset, int length, T[] mark) where T : IEquatable<T>
        {
            int num;
            return source.SearchMark<T>(offset, length, mark, 0, out num);
        }

        public static int SearchMark<T>(this IList<T> source, int offset, int length, SearchMarkState<T> searchState, out int parsedLength) where T : IEquatable<T>
        {
            int? nullable = source.SearchMark<T>(offset, length, searchState.Mark, searchState.Matched, out parsedLength);
            if (!nullable.HasValue)
            {
                searchState.Matched = 0;
                return -1;
            }
            if (nullable.Value < 0)
            {
                searchState.Matched = -nullable.Value;
                return -1;
            }
            searchState.Matched = 0;
            return nullable.Value;
        }

        public static int? SearchMark<T>(this IList<T> source, int offset, int length, T[] mark, out int parsedLength) where T : IEquatable<T>
        {
            return source.SearchMark<T>(offset, length, mark, 0, out parsedLength);
        }

        public static int? SearchMark<T>(this IList<T> source, int offset, int length, T[] mark, int matched) where T : IEquatable<T>
        {
            int num;
            return source.SearchMark<T>(offset, length, mark, matched, out num);
        }

        public static int? SearchMark<T>(this IList<T> source, int offset, int length, T[] mark, int matched, out int parsedLength) where T : IEquatable<T>
        {
            int num4;
            T local;
            int pos = offset;
            int num2 = (offset + length) - 1;
            int index = matched;
            parsedLength = 0;
            if (matched > 0)
            {
                for (num4 = index; num4 < mark.Length; num4++)
                {
                    local = source[pos++];
                    if (!local.Equals(mark[num4]))
                    {
                        break;
                    }
                    index++;
                    if (pos > num2)
                    {
                        if (index == mark.Length)
                        {
                            parsedLength = mark.Length - matched;
                            return new int?(offset);
                        }
                        return new int?(-index);
                    }
                }
                if (index == mark.Length)
                {
                    parsedLength = mark.Length - matched;
                    return new int?(offset);
                }
                pos = offset;
                index = 0;
            }
            while (true)
            {
                pos = source.IndexOf<T>(mark[index], pos, (length - pos) + offset);
                if (pos < 0)
                {
                    return null;
                }
                index++;
                for (num4 = index; num4 < mark.Length; num4++)
                {
                    int num5 = pos + num4;
                    if (num5 > num2)
                    {
                        return new int?(-index);
                    }
                    local = source[num5];
                    if (!local.Equals(mark[num4]))
                    {
                        break;
                    }
                    index++;
                }
                if (index == mark.Length)
                {
                    parsedLength = (pos - offset) + mark.Length;
                    return new int?(pos);
                }
                pos++;
                index = 0;
            }
        }

        public static int StartsWith<T>(this IList<T> source, T[] mark) where T : IEquatable<T>
        {
            return source.StartsWith<T>(0, source.Count, mark);
        }

        public static int StartsWith<T>(this IList<T> source, int offset, int length, T[] mark) where T : IEquatable<T>
        {
            int num = offset;
            int num2 = (offset + length) - 1;
            for (int i = 0; i < mark.Length; i++)
            {
                int num4 = num + i;
                if (num4 > num2)
                {
                    return i;
                }
                T local = source[num4];
                if (!local.Equals(mark[i]))
                {
                    return -1;
                }
            }
            return mark.Length;
        }
    }
}
